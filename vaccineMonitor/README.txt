Αγγελική Παναγοπούλου - 1115201800141
Προγραμματισμός Συστήματος - 1η εργασία - Εαρινό Εξάμηνο 2021

********************************
  Οργάνωση Φακέλων και Αρχείων
********************************

> mylib
    > BloomFilter
    > Date
    > HashTable
    > LinkedList
    > SkipList
> src
    > relations
    > tools
    - main.c
> testFiles (περιέχει virusesFile, countriesFile, inputFiles)
- testFile.sh 
- Makefile

*****************************
  Μεταγλώττιση και Εκτέλεση
*****************************

Δημιουργία αρχείου:
./testFile.sh virusesFile countriesFile numLines duplicatesAllowed
Τα αρχεία virusesFile και countriesFile πρέπει να βρίσκονται στον φάκελο testFiles!
Αν ο αριθμός numLines > 10K και το duplicatesAllowed = 0, τότε θα παραχθεί αρχείο με διπλότυπα στο citizenID
καθώς το citizenID παίρνει τιμή στο διάστημα [1, 9999].

Πρόγραμμα:
Στον κεντρικό φάκελο που βρίσκεται το Makefile, η μεταγλώττιση γίνεται με την εντολή make.
Τα object files αποθηκεύονται στον φάκελο build που δημιουργείται.
Το εκτελέσιμο παράγεται στον κεντρικό φάκελο και τρέχει με την εντολή:
./vaccineMonitor -c inputFiles -b bloomSize

inputFiles: το όνομα του αρχείου που δημιουργήθηκε στο tests από το testFile.sh
bloomSize: αριθμός που δηλώνει τα bytes του bloom filter. Προτείνεται να δοθεί η τιμή 100000.

*****************************
  Υλοποίηση Δομών Δεδομένων
*****************************

> mylib > LinkedList > List.h/.c

Γενικού τύπου λίστα που αποθηκεύει τα δεδομένα μέσω δείκτη. Τα στοιχεία καταστρέφονται με συνάρτηση κατάστροφης
που δίνει ο χρήστης κατά τη δημιουργία της λίστας και εκτυπώνονται με συνάρτηση εκτύπωσης που δίνει ο χρήστης
κατά την κλήση της συνάρτησης εκτύπωσης.
Λειτουργίες: δημιουργία, καταστροφή, διαγραφή στοιχείου, αναζήτηση, διάσχιση, εκτύπωση.
Ascending Ordered Linked List: Επιτυχγάνεται με κλήση της συνάρτησης list_find_order που βρίσκει τον κόμβο που
θα εισάγουμε μετά από αυτόν το στοιχείο προς εισαγωγή μέσω της list_insert_next.

Σημείωση: Το LinkedList και το HashTable είναι βελτιωμένες εκδοχές της υλοποίησής μου από το μάθημα
Δομές Δεδομένων και Τεχνικές Ποργραμματισμού με τον κ. Χατζηκοκολάκη. Ειδικότερα, το LinkedList ακολουθεί
την ίδια λογική με τη λίστα που είχε ως υπόδειγμα (πχ. χρήση void pointer για το στοιχείο της λίστας, 
δείκτες σε συναρτήσεις για την εκτέλεση των λειτουργιών κλπ).

> mylib > HashTable > HashTable.h/.c

Γενικού τύπου HashTable του οποίου ο τύπος κλειδιού δίνεται κατά τη δημιουργία του! Ο τύπος κλειδιού μπορεί
να είναι είτε Integer είτε String (δηλώνεται από το enumeration στο HashTable.h).
Λειτουργίες: δημιουργία, καταστροφή, διάσχιση, αναζήτηση, εκτύπωση.

Ένα Hash Table είναι ένας πίνακας από λίστες (List). Ανάλογα τον τύπο του κλειδιού, καλείται και η ανάλογη
hash function. Για τη διατήρηση της ομοιόμορφης κατανομής στοιχείων, με κάθε εισαγωγή στοιχείου, υπολογίζεται
ο load factor. Αν ξεπεράσει το 0.9 (δηλαδή το hash table γεμίσει κατά 90%), γίνεται rehashing όπου διπλασιάζεται
το μέγεθος του πίνακα.

Αναλυτικά σχόλια στον κώδικα εξηγούν τις λειτουργίες.

> mylib > SkipList > SkipList.h/.c

Γενικού τύπου skip list που χρησιμοποιεί για κλειδί έναν ακέραιο αριθμό.
Λειτουργίες: δημιουργία, καταστροφή, διαγραφή στοιχείου, αναζήτηση, εκτύπωση.

Ένα skip list είναι ένας πίνακας μεγέθους max level από λίστες (List). Τα Layers i (i > 0) έχουν για στοιχείο
τους έναν κόμβο sl_node που κρατά το κλειδί και έναν δείκτη σε κόμβο λίστας του κατώτερου επιπέδου. To Layer 0 
έχει για στοιχείο τη δομή που περνάει ο χρήστης. Το κλειδί της δομής προσδιορίζεται με συνάρτηση εύρεσης κλειδιού
(GetKey) που δίνει ο χρήστης κατά την εισαγωγή/αναζήτηση/διαγραφή.

Ένα στοιχείο στο Layer i εμφανίζεται στο Layer i+1 με πιθανότητα p = 1/2.
Ο αριθμός των Layers πρέπει να είναι log_(1/p)(n) όπου n το πλήθος των στοιχείων.

Η προσθήκη επιπέδου - Layer γίνεται δυναμικά, δηλαδή κάθε φορά κατά την εισαγωγή υπολογίζεται το log_(1/p)(n),
όπου n το πλήθος των στοιχείων στο Layer 0. Αν εκτιμηθεί ότι πρέπει να προστεθεί επίπεδο, κάνουμε flip a coin 
για κάθε στοιχείο του ανώτερου επιπέδου.
Ωστόσο, έχει οριστεί ένα max level: ο μέγιστος αριθμός των Layers που θα μπορούσε να έχει το skip list.
Έχει γίνει μια εκτίμηση: Ακόμα κι αν όλος ο πληθυσμός της Γης έμπαινε στο skip list, θα θέλαμε
max level = log_(2)(7.5M) = 32, αλλά τα αρχεία θα είναι αρκετά μικρότερου μεγέθους, οπότε έβαλα max level = 10.
Έχει οριστεί συνάρτηση SLCreate_with_maxlevel όπου ο χρήστης μπορεί να δημιουργήσει skip list με max level 
που θα περάσει ο ίδιος ως παράμετρο στη συνάρτηση. Όμως, κατά τη δημιουργία των skip list κάθε ιού, καλώ 
την default συνάρτηση δημιουργίας skip list με max level = 10 (> src > relations > virus.c - L76-77)

Αναλυτικά σχόλια στον κώδικα εξηγούν τις λειτουργίες.

> mylib > BloomFilter > BloomFilter.h/.c

Λειτουργίες: δημιουργία, εισαγωγή, αναζήτηση

Ένα Bloom Filter είναι πίνακας από uint8_t που το μέγεθος καθορίζεται από τον χρήστη κατά τη δημιουργία.
Μία θέση πίνακα είναι 8 bits = 1 byte, άρα όταν δίνεται για μέγεθος 100Κ bytes τότε ο πίνακας θα έχει 100Κ θέσεις.
Γίνεται διαχείριση των bits, οι hash functions έχουν δοθεί και το Κ έχει οριστεί 16. Αναλυτικά σχόλια στον κώδικα εξηγούν τις λειτουργίες.

> mylib > Date > date.h/.c

Δομή για την ημερομηνία. Αναλυτικά σχόλια στον κώδικα.

***********************
  Σχέσεις - relations
***********************

> src > relations > country.h/.c

Η δομή της χώρας. Συγκρατά το όνομα της χώρας κι έναν δυναμικό πίνακα που χρησιμοποιείται για την απάντηση
των ερωτημάτων του πληθυσμού (/populationStatus και /popStatusByAge).
Για /populationStatus: δεσμεύεται πίνακας μεγέθους 2 integers. Το popQueries[0] αποθηκεύει τα vaccinated persons
για τον ιό, ενώ το popQueries[1] τα not vaccinated για τον ίδιο ιό.
Για /popStatusByAge: δεσμεύεται πίνακας μεγέθους 8 integers. Το popQueries[0-3] αποθηκεύει τα vaccinated persons
για τον ιό για τα 4 διαστήματα ηλικιών που ζητούνται, ενώ το popQueries[4-7] τα not vaccinated για τον ίδιο ιό
και τα αντίστοιχα διαστήματα ηλικιών.
Μετά από κάθε εκτύπωση των αποτελεσμάτων για τα ερωτήματα πληθυσμού, αποδεσμεύεται η μνήμη του popQueries.

Επισημαίνεται ότι τα ερωτήματα πληθυσμού δεν θα εκτυπώσουν τις χώρες για τις οποίες δεν υπάρχει ούτε ένας πολίτης στην vaccinated_persons
και not_vaccinated_persons skip list για τον ιό που ζητείται. 
Για το ερώτημα popStatusByAge συγκεκριμένα, υπάρχει περίπτωση να βρίσκονται πολίτες στην not_vaccinated_persons skip list 
για έναν ιό, αλλά κανένας στην vaccinated_persons skip list για τον ίδιο ιό, σε μια συγκεκριμένη ηλικιακή ομάδα. 
Τότε, το ποσοστό θα είναι 0/x = 0%, όπου x ο αριθμός των πολιτών στην not_vaccinated_persons skip list.
Για μια ηλικιακή ομάδα που δεν έχει πολίτες στην not_vaccinated_persons και ούτε στην vaccinated_persons, προκύπτει
το πηλίκο 0/0 = NaN%, το οποίο ελέγχεται στην συνάρτηση popStatusByAge της country και τελικά εκτυπώνει 0%.

Αναλυτικά σχόλια στον κώδικα.

> src > relations > citizenRecord.h/.c

Η δομή του πολίτη. Συγκρατά citizenID, firstname, lastname, age και τη χώρα που είναι δείκτης στη δομή country!
Αναλυτικά σχόλια στον κώδικα.

> src > relations > virus.h/.c

Υπάρχουν δύο δομές.
Δομή vaccinated: Συγκρατά δείκτη στην δομή του πολίτη citizen και δείκτη στην ημερομηνία date.
Δομή virus: Συγκρατά το όνομα του ιού, δείκτη σε SkipList για τους vaccinated_persons του ιού, 
δείκτη σε SkipList για τους not_vaccinated_persons του ιού και δείκτη σε BloomFilter.
Αναλυτικά σχόλια στον κώδικα.

********************
  Εργαλεία - Tools
********************

> src > tools > dataStore.h/.c

Δομή dataStore: Συγκρατά τα 3 Hash Tables της εφαρμογής:
1) Για τους ιούς: Δέχεται τη δομή virus κι έχει κλειδί το όνομα του ιού (String)
2) Για τις χώρες: Δέχεται τη δομή country κι έχει κλειδί το όνομα της χώρας (String)
3) Για τους πολίτες: Δέχεται τη δομή citizenRecord κι έχει κλεδί το citizenID (Integer)
Κατά τη δημιουργία, τίθενται και οι συναρτήσεις καταστροφής destroy_virus, destroy_country, destroy_citizen.

> src > tools > utils.h/.c

Οι κύριες συναρτήσεις:
-argumentHandling: Αναλυτικά σχόλια στον κώδικα

-fileParse_and_buildStructs: 
Κάνει το file parsing και ταυτόχρονα "χτίζει" όλες τις δομές. Καλεί την συνάρτηση insertCitizen.
Αναλυτικά σχόλια στον κώδικα

-queries
Εκτελεί τα ερωτήματα και καλεί βοηθητικές συναρτήσεις που έχουν υλοποιηθεί στο utils.c 
Αναλυτικά σχόλια στον κώδικα

****************************
  Επισημάνσεις - Παραδοχές
****************************

- Οι εντολές για τους πληθυσμούς απέκτησαν το παρακάτω format
  "/populationStatus [country] virusName [date1 date2]"
  "/popStatusByAge [country] virusName [date1 date2]"
  ύστερα από διευκρινήσεις στο piazza

- Το output format του ερωτήματος /popStatusByAge είναι το ίδιο με της εκφώνησης, ωστόσο τα ποσοστά
  υπολογίζονται σύμφωνα με τα παρακάτω διαστήματα:
  [0, 20), [20, 40), [40, 60), [60, 120] κι επειδή οι ηλικίες είναι ακέραιοι αριθμοί, αυτό ανάγεται σε:
  [0, 19], [20, 39], [40, 59], [60, 120]

- Έχει προβλεφθεί κάθε λανθασμένη είσοδο χρήστη κατά τις εντολές του.
  Όταν εισαχθεί λανθασμένη εντολή, εκτυπώνεται τόσο το λάθος όσο και το σωστό format εντολής.
  ΜΟΝΟ στα ερωτήματα πληθυσμού (/populationStatus και /popStatusByAge) αν ο χρήστης δώσει το date1
  με λάθος format, τότε η εφαρμογή θα αγνοείσει τις ημερομηνίες και θα εκτελεστεί η εντολή:
  "/populationStatus [country] virusName" ή
  "/popStatusByAge [country] virusName"  

- Θεωρώ ότι το ID κάθε πολίτη είναι μοναδικό, άρα δεν μπορούν να υπάρχουν δύο διαφορετικοί πολίτες (δηλαδή να έχουν διαφορετικά
  στοιχεία όνομα/επώνυμο/χώρα/ηλικία) αλλά με ίδιο ID. Αν ο χρήστης προσπαθήσει να εκτελέσει τα ερωτήματα /insertCitizen και
  /vaccinateNow με ένα citizenID το οποίο ήδη υπάρχει στη βάση, αλλά με διαφορετικά στοιχεία, τότε η εφαρμογή θα εκτυπώσει μήνυμα
  λάθους και τα στοιχεία του πολίτη με αυτό το citizenID. Έτσι, με ένα copy-paste τα στοιχεία του πολίτη, μπορεί εύκολα να γίνει
  οποιοσδήποτε εμβολιασμός. Η συνάρτηση που ελέγχει τα στοιχεία είναι η cross_check του citizenRecord.

- Στον φάκελο testFiles θα βρείτε ήδη αρχεία που έχουν δημιουργηθεί από το testFile.sh με το εξής format:
  inputFile50K_1 σημαίνει ότι έχουμε 50Κ γραμμές και το duplicatesAllowed = 1.
